\documentclass[11pt,a4paper]{book}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

% Unicode character definitions
\DeclareUnicodeCharacter{2081}{\textsubscript{1}}
\DeclareUnicodeCharacter{2082}{\textsubscript{2}}
\DeclareUnicodeCharacter{2192}{$\rightarrow$}
\DeclareUnicodeCharacter{2227}{$\land$}
\DeclareUnicodeCharacter{03BC}{$\mu$}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{mathtools}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[backend=biber,style=numeric,sorting=nyt,maxbibnames=10]{biblatex}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{thmtools}
\usepackage{cleveref}
\usepackage{booktabs}
\usepackage{array}

% Add the bibliography resource
\addbibresource{lion-ecosystem.bib}

% Page geometry
\geometry{
    top=1in,
    bottom=1in,
    left=1in,
    right=1in
}

% Theorem environments
\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]
\newtheorem{example}[definition]{Example}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{corollary}[definition]{Corollary}
\newtheorem{claim}[definition]{Claim}

\theoremstyle{remark}
\newtheorem{remark}[definition]{Remark}

% Proof environment (provided by amsthm)
\renewcommand{\qedsymbol}{\ensuremath{\blacksquare}}

% Custom abstract environment for book class
\newenvironment{abstract}%
{\begin{center}%
\bfseries\abstractname\vspace{-.5em}\vspace{0pt}%
\end{center}%
\list{}{%
\setlength{\leftmargin}{2cm}%
\setlength{\rightmargin}{\leftmargin}%
}%
\item\relax}
{\endlist}
\providecommand{\abstractname}{Abstract}

% Rust language definition for listings
\lstdefinelanguage{Rust}{
    keywords={
        as, break, const, continue, crate, else, enum, extern, fn, for, if, impl, in, let, loop, match, mod, move, mut, pub, ref, return, self, Self, static, struct, super, trait, type, unsafe, use, where, while, async, await, dyn
    },
    keywords=[2]{
        bool, char, f32, f64, i8, i16, i32, i64, i128, isize, str, u8, u16, u32, u64, u128, usize, Box, Vec, HashMap, String, Option, Result, None, Some, Ok, Err
    },
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
    morestring=[b]',
    sensitive=true,
}

% Code listing settings
\lstdefinestyle{rust}{
    language=Rust,
    keywordstyle=[2]\color{purple},
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

\lstdefinestyle{lean}{
    language=Haskell,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

\lstdefinestyle{python}{
    language=Python,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

\lstdefinestyle{tla}{
    language=,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue},
    commentstyle=\color{green!50!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    rulecolor=\color{black},
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)}
}

% Custom commands for mathematical notation
\newcommand{\LionComp}{\mathbf{LionComp}}
\newcommand{\Set}{\mathbf{Set}}
\newcommand{\Obj}{\mathrm{Obj}}
\newcommand{\Hom}{\mathrm{Hom}}
\newcommand{\id}{\mathrm{id}}
\newcommand{\Policies}{\mathbf{P}}
\newcommand{\AccessRequests}{\mathbf{A}}
\newcommand{\Capabilities}{\mathbf{C}}
\newcommand{\Workflows}{\mathbf{W}}
\newcommand{\Decisions}{\text{Decisions}}
\newcommand{\PERMIT}{\text{PERMIT}}
\newcommand{\DENY}{\text{DENY}}
\newcommand{\INDETERMINATE}{\text{INDETERMINATE}}
\newcommand{\SAFE}{\text{SAFE}}

% Capability system commands
\newcommand{\authority}{\text{authority}}
\newcommand{\compatible}{\text{compatible}}
\newcommand{\secure}{\text{secure}}
\newcommand{\unforgeable}{\text{unforgeable}}
\newcommand{\send}{\text{send}}
\newcommand{\receive}{\text{receive}}
\newcommand{\perform}{\text{perform}}

% Title and author information
\title{
\Large \textbf{Lion Ecosystem Formal Verification} \\
\large Complete Mathematical Foundations for Secure Microkernel Architecture \\
\vspace{0.5cm}
\normalsize A Comprehensive Formal Framework for Capability-Based Security, \\
Memory Isolation, Policy Evaluation, and Workflow Orchestration
}
\author{Haiyang Li - ocean@lionagi.ai}
\date{Version 1.0 -- July 11, 2025}

\begin{document}

\maketitle

\begin{abstract}
This document presents the complete formal verification framework for the Lion ecosystem, establishing mathematical foundations for a secure microkernel architecture with end-to-end correctness guarantees. Through five comprehensive chapters, we develop and prove fundamental theorems covering categorical foundations, capability-based security, memory isolation, policy evaluation, and workflow orchestration.

\textbf{Key Theoretical Contributions:}
\begin{enumerate}
\item \textbf{Category Theory Foundations}: Mathematical framework for composable system architectures with functorial semantics
\item \textbf{Capability-Based Security}: Formal proofs of confinement, revocation, delegation, and attenuation properties
\item \textbf{Memory Isolation Guarantees}: WebAssembly-based isolation with mathematical proof of memory safety and deadlock freedom
\item \textbf{Policy Evaluation Correctness}: Three-valued logic system with polynomial-time complexity and soundness guarantees
\item \textbf{Workflow Termination Proofs}: DAG-based execution model with bounded resource consumption and finite-time completion
\item \textbf{End-to-End Integration}: System-wide invariant preservation across all component interactions
\end{enumerate}

\textbf{Practical Significance:}
The Lion ecosystem demonstrates that formal verification can be successfully integrated with modern systems programming, providing mathematical guarantees for enterprise-grade deployments while maintaining practical performance characteristics. The framework enables confident deployment in security-critical environments including financial services, healthcare, government, and critical infrastructure.

\textbf{Implementation Architecture:}
All formal specifications correspond directly to Rust implementations with WebAssembly isolation, creating a complete theory-to-practice mapping that maintains formal properties in executable code.
\end{abstract}

\tableofcontents

\chapter{Categorical Foundations \& Composable Architecture}
\input{ch1_content}

\chapter{Capability-Based Security \& Access Control}
\input{ch2_content}

\chapter{Memory Isolation \& Concurrency Safety}
\input{ch3_content}

\chapter{Policy \& Workflow Correctness}
\input{ch4_content}

\chapter{Integration \& Future Directions}
\input{ch5_content}

% Bibliography
\nocite{*}  % This forces ALL bibliography entries to appear
\printbibliography[title={Bibliography}]

\chapter{Conclusion}

The Lion ecosystem formal verification framework represents a significant advancement in the practical application of mathematical rigor to systems programming. Through five comprehensive chapters, we have established:

\textbf{Theoretical Foundation}: A complete mathematical framework spanning category theory, capability-based security, memory isolation, policy evaluation, and workflow orchestration, with all major theorems formally proven.

\textbf{Practical Implementation}: Direct correspondence between formal specifications and executable Rust code with WebAssembly isolation, demonstrating that formal verification can be successfully integrated with modern systems programming practices.

\textbf{Enterprise Readiness}: Polynomial-time complexity bounds and mathematical guarantees that enable confident deployment in security-critical environments requiring the highest levels of assurance.

\textbf{Research Impact}: Identification of future directions that position Lion as a platform for advancing formal verification into emerging domains including quantum computing, distributed systems, and real-time verification.

The successful integration of formal methods with practical systems development demonstrated in this work establishes a new paradigm for building trustworthy systems at scale, providing a blueprint for security-critical applications across industries.

\end{document}